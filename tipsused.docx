While you are making the bot, you shall use State to avoid:

Imagine you just add a new handler like @dp.message(). After you get the phone number, the user sends their email. 
It works! But what if the user sends /start, gets the phone number prompt, and then just types "hello"? Y
our new handler would fire and try to save "hello" as an email, which is wrong.
You need a way for your bot to know that it is specifically waiting for an email. This "waiting for" status is called a state.

**The Solution: Finite State Machine (FSM)**

Think of FSM as giving your bot a short-term memory. You define a set of states for your conversation, and you can move the user from one state to another.
Here’s the process:
Define States: Create a class that lists all the steps in your conversation (e.g., WaitingForEmail).
Enter a State: After getting the phone number, you'll tell the bot, "Now, enter the WaitingForEmail state for this user."
Create a State-Specific Handler: Create a new handler that only triggers if the user is in the WaitingForEmail state.
Process Data and Exit State: Once you receive the email, you save it and then clear the state, bringing the conversation back to normal.


First, you need to import FSMContext for managing the state and State, StatesGroup for defining them. 
Then, create a class for your registration process.



While you are pushing to github, use hiding or .env to hid the token of your bot.


#Bot as an object(hide token#)
For entries with type Secret* you need to
call the get_secret_value() method,
to get the real content instead of '*******'
bot = Bot(token= config.bot_token.get_secret_value())
The dispatcher receives updates from Telegram, which can include various types of interactions like messages, commands, or other events.


When you make handlers, do not forget make function async!


Not all functionality of the bot can be implemented as single handler, 
for example you will need to collect some data from user in separated steps you will need to use FSM.

Using States is crucial for storing data of the user.

If you want InlineKeyboardButton for requesting phone number, can do with just KeyboardButton:
The Fundamental Rule: request_contact is Special
For security and user privacy, Telegram has a strict rule:
The ability to request a user's phone number (request_contact=True) or location (request_location=True) is exclusively available for KeyboardButton objects, which can only be used inside a ReplyKeyboardMarkup.
Why this rule exists:
ReplyKeyboardMarkup (The one you are using correctly): 
This keyboard replaces the user's standard text keyboard at the bottom of the screen. 
It is a very clear and explicit prompt. When a user sees this, they understand the bot is asking for a special permission or action. 
It's a "heavyweight" interaction.
InlineKeyboardMarkup (The one you want to switch to): These are the small buttons attached directly to a message. 
They are designed for "lightweight" interactions like navigating menus, clicking a link, or sending a simple callback_data signal (like "yes", "no", "next_page"). 
They are not allowed to perform sensitive actions like requesting private user data directly.


When you put this Series into an if statement, Python gets confused. It looks at [False, True, False] and asks, "Is this whole list True or False?"
 It can't decide, so it raises the "ambiguous" error. Working with Series, check how it shall be doing it.

Used Calendar date selection directly from chat.

# The library's process_selection method handles everything.
    # It returns True and the selected date if a date was chosen.
    # It returns False and a new calendar markup if the user navigated months.
    selected, LSTEP = await calendar.process_selection(callback, callback_data)