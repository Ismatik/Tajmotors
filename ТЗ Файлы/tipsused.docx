While you are making the bot, you shall use State to avoid:

Imagine you just add a new handler like @dp.message(). After you get the phone number, the user sends their email. 
It works! But what if the user sends /start, gets the phone number prompt, and then just types "hello"? Y
our new handler would fire and try to save "hello" as an email, which is wrong.
You need a way for your bot to know that it is specifically waiting for an email. This "waiting for" status is called a state.

**The Solution: Finite State Machine (FSM)**

Think of FSM as giving your bot a short-term memory. You define a set of states for your conversation, and you can move the user from one state to another.
Here’s the process:
Define States: Create a class that lists all the steps in your conversation (e.g., WaitingForEmail).
Enter a State: After getting the phone number, you'll tell the bot, "Now, enter the WaitingForEmail state for this user."
Create a State-Specific Handler: Create a new handler that only triggers if the user is in the WaitingForEmail state.
Process Data and Exit State: Once you receive the email, you save it and then clear the state, bringing the conversation back to normal.


First, you need to import FSMContext for managing the state and State, StatesGroup for defining them. 
Then, create a class for your registration process.



While you are pushing to github, use hiding or .env to hid the token of your bot.


#Bot as an object(hide token#)
For entries with type Secret* you need to
call the get_secret_value() method,
to get the real content instead of '*******'
bot = Bot(token= config.bot_token.get_secret_value())
The dispatcher receives updates from Telegram, which can include various types of interactions like messages, commands, or other events.


When you make handlers, do not forget make function async!


Not all functionality of the bot can be implemented as single handler, 
for example you will need to collect some data from user in separated steps you will need to use FSM.

Using States is crucial for storing data of the user.

If you want InlineKeyboardButton for requesting phone number, can do with just KeyboardButton:
The Fundamental Rule: request_contact is Special
For security and user privacy, Telegram has a strict rule:
The ability to request a user's phone number (request_contact=True) or location (request_location=True) is exclusively available for KeyboardButton objects, which can only be used inside a ReplyKeyboardMarkup.
Why this rule exists:
ReplyKeyboardMarkup (The one you are using correctly): 
This keyboard replaces the user's standard text keyboard at the bottom of the screen. 
It is a very clear and explicit prompt. When a user sees this, they understand the bot is asking for a special permission or action. 
It's a "heavyweight" interaction.
InlineKeyboardMarkup (The one you want to switch to): These are the small buttons attached directly to a message. 
They are designed for "lightweight" interactions like navigating menus, clicking a link, or sending a simple callback_data signal (like "yes", "no", "next_page"). 
They are not allowed to perform sensitive actions like requesting private user data directly.


When you put this Series into an if statement, Python gets confused. It looks at [False, True, False] and asks, "Is this whole list True or False?"
 It can't decide, so it raises the "ambiguous" error. Working with Series, check how it shall be doing it.

Used Calendar date selection directly from chat.

# The library's process_selection method handles everything.
    # It returns True and the selected date if a date was chosen.
    # It returns False and a new calendar markup if the user navigated months.
    selected, LSTEP = await calendar.process_selection(callback, callback_data)

Made the handler to awake, but it did not work - WHY?

Of course! You've run into one of the most fundamental and important concepts of Finite State Machines (FSM). This is a perfect example to learn from.
The reason your process_time_service handler doesn't run is that the bot is waiting for a message that it never asked for.
Let's trace the logic step-by-step to see where the chain of events breaks.
The Problem: The Broken Chain
User Clicks a Date: The user interacts with the calendar.
process_simple_calendar Runs: This callback_query handler correctly catches the button click.
Inside the Handler:
It checks if a valid, future date was selected.
It sends a confirmation message: await callback_query.message.answer('You selected ...').
It saves the date to the state: await state.update_data(date=...).
It sets the state for the next step: await state.set_state(TestDrive.time).
And then the function ends.
At this point, the bot has done its job. It has successfully processed the date and is now in the TestDrive.time state. The handler it's waiting for is @dp.message(TestDrive.time), which expects the user to send a text message.
But look at it from the user's perspective. They just saw "You selected [the date]. Our manager will contact you soon!" They have not been asked to type anything else. They have no reason to send a message, so the process_time_service handler is never triggered.
The Solution: Ask, Then Wait
The core principle of FSM is that a handler should process the current information and then ask the question for the next state.
You need to modify your process_simple_calendar handler to explicitly ask the user for the time.



I want to separate test drive handler in separate file, from main - how to make that?
That is an excellent and very professional step to take! Separating your handlers into different files (a concept often called "blueprints" or "routers" in web frameworks) is the best way to keep your main bot file clean and manage a large project.
In aiogram 3.x, the tool for this is the Router.
A Router acts like a mini-Dispatcher. You can attach handlers to it just like you do with dp, and then you "plug" that router into your main dispatcher.
Here is the complete, step-by-step guide to move your TestDrive FSM flow into its own file.
The Strategy
Create a New File: We'll make a new Python file, for example, handlers/test_drive.py.
Create a Router: Inside this new file, we will create an instance of Router.
Move the Code: We will cut and paste all the TestDrive-related code (the StatesGroup, the register_testdrive function, and all the handlers) into this new file.
Change Decorators: We'll change all the decorators from @dp. to @router. (using the name of our new router).
Import in Main File: In your main bot file (tajmotors.py), we will import the new router.
Include the Router: We'll tell the main dispatcher (dp) to include all the handlers from our new router using dp.include_router().


Admin part needed to be done with FastAPI library, using app = FastAPI. Ping it with Postman, so it makes newslettering by that.

If you do not use CALLBACK_DATA - how to do it different way?

# This is the handler that catches the "Edit Profile" button press.
# It listens for a MESSAGE where the TEXT is one of the values
# from your BUTTON_EDIT_PROFILE dictionary.
#@router.message(F.text.in_(BUTTON_EDIT_PROFILE.values()))